import numpy as np
import os.path
import json, re, argparse, sys
import matplotlib as mpl
import matplotlib.pyplot as plt
from js.utils.plot.colors import colorScheme

mpl.rc('font',size=30) 
mpl.rc('lines',linewidth=3.)
figSize = (14, 5.5)
figSize = (12, 8)
figSize = (20, 8)
figSize = (14, 10)
c1 = colorScheme("labelMap")["turquoise"]
c2 = colorScheme("labelMap")["orange"]
c3 = colorScheme("labelMap")["red"]
colors = colorScheme("label")

parser = argparse.ArgumentParser(description = 'plot results from results.json files generated by randomRenderAndCompare.py')
parser.add_argument('-i','--input',
    default="/data/vision/fisher/expres1/jstraub/optRotTransCVPR2017_bunny/", help='path to results folder')
#    default="/media/jstraub/research/dpOptTrans/", help='path to results folder')
#    default="/home/jstraub/CloudStation/research/dpOptTrans/", help='path to results folder')
#    default="../optRotTrans/", help='path to results folder')
cmdArgs = parser.parse_args()

name = "[a-z_0-9]+_[0-9]+_results.json"

results = []
for root, dirs, files in os.walk(cmdArgs.input):
  for f in files:
    if re.search(name, f):    
      results.append(os.path.join(root,f))
  break # don recurse into subfolders

version = "4.3"
version = "4.4"
version = "4.2"
scale = 2*0.1 # roughly the diameter to bound the bunny

errors = {"err_a":{}, "err_t":{}, "dt":{}, "Ks":{}, "overlap":[], "dangle":[],
    "noise":[], "outlier":[],
  "dtranslation":[]}
errTypes = ["err_a", "err_t", "dt", "Ks"]
counter = 0
numRejected = dict()
for result in results:
  r = json.load(open(result))
  if r['version'] == version:
#    print result
    errors["overlap"].append(r['GT']['overlap'])
    errors["noise"].append(r['GT']['noiseStd'])
    errors["outlier"].append(r['GT']['outlier'])
#    dang = 2.*np.arccos(r['GT']['q'][0]) *180/np.pi
#    errors["dangle"].append(dang)
#    errors["dtranslation"].append(np.sqrt((np.array(r['GT']['t'])**2).sum()))
    errors["dangle"].append(r['GT']['dangle'])
    errors["dtranslation"].append(r['GT']['dtranslation'])
    # enforce that all values of one scene be non nan
#    isnotnan = True
#    for algKey, val in r.iteritems():
#      if not algKey in ["GT", "version", "ICP"]:
#        for i,typ in enumerate(errTypes):
#          if not typ in val:
#            continue
#          isnotnan = isnotnan and (not np.isnan(val[typ]).any())
#          if np.isnan(val[typ]).any():
#            if algKey in numRejected:
#              numRejected[algKey] += 1
#            else:
#              numRejected[algKey] = 1
#    if not isnotnan:
#      continue
    # collect the values
    for algKey, val in r.iteritems():
      if not algKey in ["GT", "version"]:
        for typ in errTypes:
          if not typ in val:
            continue
          if algKey in errors[typ]:
            errors[typ][algKey].append(val[typ])
          else:
            errors[typ][algKey] = [val[typ]]
    counter += 1 
#    if counter > 100:
#      break
totalRejected = 0
for key,val in numRejected.iteritems():
  totalRejected += val
print "Found {} valid and {} invalid result files. Found the following breakdown of invalid files:".format(counter, totalRejected)
for key,val in numRejected.iteritems():
  print "  {}: \t{}\t{}%".format(key, val, 100.*val/float(totalRejected+counter))

print "have the following algorithms: "
for key in errors["err_a"].iterkeys():
  print "  ", key

if counter == 0:
  print "No results found for version "+version
  sys.exit(0)

errDesc = {"err_a":"$\Delta \\theta$ [deg]", 
    "err_t": "$\|\|\Delta t\|\|_2$ [m]", "dt":"dt [s]",
    "Ks1":"Ks", "Ks2":"Ks", "Ks3":"Ks", "Ks4":"Ks"}
errTypeMax = {"err_a": 90., "err_t": 0.2, "dt": 120.,
    "Ks1":30, "Ks2":30, "Ks3":30, "Ks4":30}
yMetricLabel={"overlap":"overlap [%]", "noise":"noise",
  "outlier":"outlier", "dangle":" $\Delta\\theta_{GT}$ [deg]",
  "dtranslation":"$\|\|\Delta t_{GT}\|\|_2$ [m]"}
yMetricResolution={"overlap":9, "dangle":8, "dtranslation":0.4}
yMetricResolution={"overlap":15, "dangle":12, "dtranslation":0.4, 
    "noise":1., "outlier":0.1}
#yMetricResolution={"overlap":15, "dangle":12, "dtranslation":0.4}

# eval of all algos against eachother
errTypes = ["err_a", "err_t"] #, "dt"]
algTypes = ["BB", "BB+ICP"]

if not "DISPLAY" in os.environ:
  sys.exit(0)

print algTypes
print errTypes

print len(errors["err_a"]["BB"])
print len(errors["noise"])

noises = np.sort(np.unique(errors["noise"]))
noiseQuant = {}
for i,n in enumerate(noises):
  noiseQuant[n] = i
outliers = np.sort(np.unique(errors["outlier"]))
outlierQuant = {}
for i,o in enumerate(outliers):
  outlierQuant[o] = i
print noises
print outliers

for errType in errTypes:
  for algType in ["BB"]:
    print algType, len(errors[errType][algType])
    errA = np.zeros((len(noises),len(outliers)))
    errSq = np.zeros((len(noises),len(outliers)))
    errAN = np.zeros((len(noises),len(outliers)))
    errT = np.zeros((len(noises),len(outliers)))
    for i,n in enumerate(errors["noise"]):
      o = errors["outlier"][i]
      err = errors[errType][algType][i]
      if errType == "err_t":
        err /= scale
      if not np.isnan(err):
        errA[noiseQuant[n], outlierQuant[o]] += err
        errSq[noiseQuant[n], outlierQuant[o]] += err*err
        errAN[noiseQuant[n], outlierQuant[o]] += 1
    errA /= errAN
    errStd = np.sqrt((errSq - errA*errA*errAN)/(errAN-1))
    fig = plt.figure(figsize = figSize, dpi = 80, facecolor="w", edgecolor="k")
    for i,o in enumerate(outliers[::2]):
      plt.plot(noises/scale, errA[:,i], label="{}".format(o),color=colors[i%len(colors)])
      plt.fill_between(noises/scale, np.minimum(errA[:,i]-errStd[:,i],np.zeros_like(errStd[:,i])),
          errA[:,i]+errStd[:,i], alpha=0.3, color=colors[i%len(colors)])
#      plt.plot(noises/scale, errA[:,i]+errStd[:,i],alpha=0.3,color=colors[i%len(colors)])
#      plt.plot(noises/scale, errA[:,i]-errStd[:,i],alpha=0.3,color=colors[i%len(colors)])
    plt.legend(loc="best")
#    plt.title("{} {}".format(algType, errType))

#    errA = errA[::-1,:]
#    fig = plt.figure(figsize = figSize, dpi = 80, facecolor="w", edgecolor="k")
#    fig.add_subplot(111)
#    cRange = [0,47.]
#    if errType == "err_t":
#      cRange = [0,2.8]
#    ax1 = plt.imshow(errA, interpolation="nearest", 
#        extent=[noises.min(), noises.max(), outliers.min(), outliers.max()],
#        vmin=cRange[0], vmax=cRange[1])
#
#    if algType == "BB":
#      cbaxes = fig.add_axes([0.8, 0.1, 0.03, 0.8]) 
#      cb = plt.colorbar(ax1, cax = cbaxes)  
#      cbar = plt.colorbar(ax1, shrink=0.65, pad = 0.05)
#    if algType == "BB" and errType == "err_t":
  #    plt.title("{} {}".format(algType, errType))
    plt.xlabel("noise std")
    plt.ylabel(errDesc[errType])
#    else:
#      plt.xticks([])
#      plt.yticks([])
    plt.tight_layout()
    plt.savefig("errorPltNoiseOutlier_{}_{}_results.png".format(errType,algType), figure=fig)
plt.show()

